export const shaders = {
  "ORIGINAL": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvoid main() {\r\n    vec4 texColor = texture2D(texture, texCoords);\r\n    gl_FragColor = texColor; // Original color\r\n}",
  "AREA": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 resolution; // Canvas-size\r\nuniform vec2 bottomLeft; // Uniform-Variable for left bottom corner\r\nuniform vec2 topRight; // Uniform-Variable for right top corner\r\nvoid main() {\r\n    vec4 texColor = texture2D(texture, texCoords);\r\n    // Transformation of normalised texCoords in screen coordinates\r\n    vec2 screenCoords = texCoords * resolution;\r\n    // Check if pixel in selected area\r\n    if (screenCoords.x >= bottomLeft.x && screenCoords.x <= topRight.x &&\r\n        screenCoords.y >= bottomLeft.y && screenCoords.y <= topRight.y) {\r\n        // Pixel processing with desired algorithm\r\n        float brightness = max(max(texColor.r, texColor.g), texColor.b);\r\n        if (brightness >= 0.6) {\r\n            float redIntensity = (brightness - 0.6) / (1.0 - 0.6);\r\n            gl_FragColor = vec4(redIntensity, 0.0, 0.0, 1.0); // Red value\r\n        } else {\r\n            gl_FragColor = texColor; // Original value, of not above treshold\r\n        }\r\n    } else {\r\n        // No processing for individual pixel if out of selected area\r\n        gl_FragColor = texColor;\r\n    }\r\n}",
  "CONTRAST": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvoid main() {\r\n    vec4 color = texture2D(texture, texCoords);\r\n    float contrast = 5.0; // Factor for Contrast strength\r\n    color.rgb /= color.a;\r\n    color.rgb = ((color.rgb - 0.5) * max(contrast, 0.0)) + 0.5;\r\n    color.rgb *= color.a;\r\n    gl_FragColor = color;\r\n}",
  "GAUSS": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 texSize;\r\nvoid main() {\r\n    vec2 texOffset = 1.0 / texSize; // Gets size of single texel\r\n    vec4 result = vec4(0.0);\r\n    for(int x = -2; x <= 2; x++) {\r\n        for(int y = -2; y <= 2; y++) {\r\n            vec2 offset = vec2(float(x), float(y)) * texOffset;\r\n            result += texture2D(texture, texCoords + offset) * 0.04;\r\n        }\r\n    }\r\n    gl_FragColor = result;\r\n}",
  "HIGHLIGHTING": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvoid main() {\r\n    vec4 texColor = texture2D(texture, texCoords);\r\n    float brightness = max(max(texColor.r, texColor.g), texColor.b);\r\n    if (brightness >= 0.6) {\r\n        float redIntensity = (brightness - 0.6) / (1.0 - 0.6);\r\n        gl_FragColor = vec4(redIntensity, 0.0, 0.0, 1.0); // Proper red tone\r\n    } else {\r\n        gl_FragColor = texColor; // Original color\r\n    }\r\n}",
  "INVERT": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvoid main() {\r\n    vec4 color = texture2D(texture, texCoords);\r\n    gl_FragColor = vec4(vec3(1.0) - color.rgb, color.a);\r\n}",
  "LAPLACE_EDGE": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 texSize;\r\nvoid main() {\r\n    float dx = 1.0 / texSize.x;\r\n    float dy = 1.0 / texSize.y;\r\n    vec3 color = vec3(0.0);\r\n    color += texture2D(texture, texCoords + vec2(-dx, -dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(0.0, -dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(dx, -dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(-dx, 0.0)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(dx, 0.0)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(-dx, dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(0.0, dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(dx, dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords).rgb * 8.0;\r\n\r\n    color = color * 2.0; // Adjust this factor to increase brightness and contrast\r\n\r\n    gl_FragColor = vec4(color, 1.0);\r\n}",
  "PSEUDOCOLOR": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvec3 grayscaleToColor(float gray) {\r\n    float r = smoothstep(0.0, 0.5, gray) - smoothstep(0.5, 1.0, gray);\r\n    float g = smoothstep(0.25, 0.75, gray);\r\n    float b = 1.0 - smoothstep(0.0, 1.0, gray);\r\n    return vec3(r, g, b);\r\n}\r\nvoid main() {\r\n    vec4 color = texture2D(texture, texCoords);\r\n    float intensity = color.r;\r\n    vec3 pseudocolor = grayscaleToColor(intensity);\r\n    gl_FragColor = vec4(pseudocolor, color.a);\r\n}",
  "SHARPENING": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 texSize;\r\nvoid main() {\r\n    float dx = 1.0 / texSize.x;\r\n    float dy = 1.0 / texSize.y;\r\n    float strength = 10.0; // Strength of sharpening effect\r\n    vec4 texColor = texture2D(texture, texCoords);\r\n    vec4 texColorLeft = texture2D(texture, texCoords + vec2(-dx, 0.0));\r\n    vec4 texColorRight = texture2D(texture, texCoords + vec2(dx, 0.0));\r\n    vec4 texColorUp = texture2D(texture, texCoords + vec2(0.0, dy));\r\n    vec4 texColorDown = texture2D(texture, texCoords + vec2(0.0, -dy));\r\n    vec4 edge = texColor * (1.0 + 4.0 * strength) - (texColorLeft + texColorRight + texColorUp + texColorDown) * strength;\r\n    gl_FragColor = vec4(edge.rgb, texColor.a);\r\n}",
  "SMILEY": "precision mediump float;\r\nuniform vec2 resolution; // Canvas size\r\nvoid main() {\r\n    vec2 center = vec2(0.5, 0.5); // Center of Smiley in normalised coordinates\r\n    float radius = 0.4; // Radius Smiley\r\n    float eyeRadius = 0.05;\r\n    float mouthWidth = 0.05;\r\n    float smileRadius = 0.3;\r\n    // Transform Pixel-coordinates to normalised coordinates\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec2 uvCentered = uv - center;\r\n    // Calculation distance from center\r\n    float dist = length(uvCentered);\r\n    // Draw Face\r\n    vec3 color = vec3(0.0);\r\n    if (dist < radius) {\r\n        color = vec3(1.0, 1.0, 0.0); // face in yellow\r\n        // Eyes\r\n        vec2 leftEyePos = center + vec2(-0.15, 0.1);\r\n        vec2 rightEyePos = center + vec2(0.15, 0.1);\r\n        float leftEyeDist = length(uv - leftEyePos);\r\n        float rightEyeDist = length(uv - rightEyePos);\r\n        if (leftEyeDist < eyeRadius || rightEyeDist < eyeRadius) {\r\n            color = vec3(0.0);\r\n        }\r\n        // Mouth\r\n        float mouthDist = length(uvCentered + vec2(0.0, -0.15));\r\n        if (mouthDist < smileRadius + mouthWidth && mouthDist > smileRadius - mouthWidth && uv.y < center.y) {\r\n            color = vec3(1.0, 0.0, 0.0); // mouth in red\r\n        }\r\n    }\r\n    gl_FragColor = vec4(color, 1.0);\r\n}",
  "SOBEL_EDGE": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 texSize;\r\nvoid main() {\r\n    float dx = 1.0 / texSize.x;\r\n    float dy = 1.0 / texSize.y;\r\n    vec3 grad_x = vec3(0.0);\r\n    vec3 grad_y = vec3(0.0);\r\n    vec3 texTL = texture2D(texture, texCoords + vec2(-dx, -dy)).rgb; // Top-left\r\n    vec3 texTC = texture2D(texture, texCoords + vec2(0.0, -dy)).rgb; // Top-center\r\n    vec3 texTR = texture2D(texture, texCoords + vec2(dx, -dy)).rgb;  // Top-right\r\n    vec3 texCL = texture2D(texture, texCoords + vec2(-dx, 0.0)).rgb; // Center-left\r\n    vec3 texCC = texture2D(texture, texCoords).rgb;                  // Center-center\r\n    vec3 texCR = texture2D(texture, texCoords + vec2(dx, 0.0)).rgb;  // Center-right\r\n    vec3 texBL = texture2D(texture, texCoords + vec2(-dx, dy)).rgb;  // Bottom-left\r\n    vec3 texBC = texture2D(texture, texCoords + vec2(0.0, dy)).rgb;  // Bottom-center\r\n    vec3 texBR = texture2D(texture, texCoords + vec2(dx, dy)).rgb;   // Bottom-right\r\n\r\n    // Apply Sobel operator for X gradient\r\n    grad_x += texTL * vec3(-1.0) + texTC * vec3(0.0) + texTR * vec3(1.0);\r\n    grad_x += texCL * vec3(-2.0) + texCC * vec3(0.0) + texCR * vec3(2.0);\r\n    grad_x += texBL * vec3(-1.0) + texBC * vec3(0.0) + texBR * vec3(1.0);\r\n\r\n    // Apply Sobel operator for Y gradient\r\n    grad_y += texTL * vec3(-1.0) + texTC * vec3(-2.0) + texTR * vec3(-1.0);\r\n    grad_y += texCL * vec3(0.0) + texCC * vec3(0.0) + texCR * vec3(0.0);\r\n    grad_y += texBL * vec3(1.0) + texBC * vec3(2.0) + texBR * vec3(1.0);\r\n\r\n    float edgeStrength = length(grad_x) + length(grad_y);\r\n    gl_FragColor = vec4(vec3(edgeStrength), 1.0);\r\n}"
};