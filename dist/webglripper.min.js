const $b2f097dd1b44c49c$export$866b86194d51abc4 = {
    "STANDARD": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvoid main() {\r\n    vec4 texColor = texture2D(texture, texCoords);\r\n    float brightness = max(max(texColor.r, texColor.g), texColor.b);\r\n    if (brightness >= 0.6) {\r\n        float redIntensity = (brightness - 0.6) / (1.0 - 0.6);\r\n        gl_FragColor = vec4(redIntensity, 0.0, 0.0, 1.0); // Proper red tone\r\n    } else {\r\n        gl_FragColor = texColor; // Original color\r\n    }\r\n}",
    "AREA": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 resolution; // Canvas-size\r\nuniform vec2 bottomLeft; // Uniform-Variable for left bottom corner\r\nuniform vec2 topRight; // Uniform-Variable for right top corner\r\nvoid main() {\r\n    vec4 texColor = texture2D(texture, texCoords);\r\n    // Transformation of normalised texCoords in screen coordinates\r\n    vec2 screenCoords = texCoords * resolution;\r\n    // Check if pixel in selected area\r\n    if (screenCoords.x >= bottomLeft.x && screenCoords.x <= topRight.x &&\r\n        screenCoords.y >= bottomLeft.y && screenCoords.y <= topRight.y) {\r\n        // Pixel processing with desired algorithm\r\n        float brightness = max(max(texColor.r, texColor.g), texColor.b);\r\n        if (brightness >= 0.6) {\r\n            float redIntensity = (brightness - 0.6) / (1.0 - 0.6);\r\n            gl_FragColor = vec4(redIntensity, 0.0, 0.0, 1.0); // Red value\r\n        } else {\r\n            gl_FragColor = texColor; // Original value, of not above treshold\r\n        }\r\n    } else {\r\n        // No processing for individual pixel if out of selected area\r\n        gl_FragColor = texColor;\r\n    }\r\n}",
    "CONTRAST": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvoid main() {\r\n    vec4 color = texture2D(texture, texCoords);\r\n    float contrast = 5.0; // Factor for Contrast strength\r\n    color.rgb /= color.a;\r\n    color.rgb = ((color.rgb - 0.5) * max(contrast, 0.0)) + 0.5;\r\n    color.rgb *= color.a;\r\n    gl_FragColor = color;\r\n}",
    "GAUSS": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 texSize;\r\nvoid main() {\r\n    vec2 texOffset = 1.0 / texSize; // Gets size of single texel\r\n    vec4 result = vec4(0.0);\r\n    for(int x = -2; x <= 2; x++) {\r\n        for(int y = -2; y <= 2; y++) {\r\n            vec2 offset = vec2(float(x), float(y)) * texOffset;\r\n            result += texture2D(texture, texCoords + offset) * 0.04;\r\n        }\r\n    }\r\n    gl_FragColor = result;\r\n}",
    "INVERT": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvoid main() {\r\n    vec4 color = texture2D(texture, texCoords);\r\n    gl_FragColor = vec4(vec3(1.0) - color.rgb, color.a);\r\n}",
    "LAPLACE_EDGE": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 texSize;\r\nvoid main() {\r\n    float dx = 1.0 / texSize.x;\r\n    float dy = 1.0 / texSize.y;\r\n    vec3 color = vec3(0.0);\r\n    color += texture2D(texture, texCoords + vec2(-dx, -dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(0.0, -dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(dx, -dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(-dx, 0.0)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(dx, 0.0)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(-dx, dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(0.0, dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords + vec2(dx, dy)).rgb * -1.0;\r\n    color += texture2D(texture, texCoords).rgb * 8.0;\r\n\r\n    color = color * 2.0; // Adjust this factor to increase brightness and contrast\r\n\r\n    gl_FragColor = vec4(color, 1.0);\r\n}",
    "PSEUDOCOLOR": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nvec3 grayscaleToColor(float gray) {\r\n    float r = smoothstep(0.0, 0.5, gray) - smoothstep(0.5, 1.0, gray);\r\n    float g = smoothstep(0.25, 0.75, gray);\r\n    float b = 1.0 - smoothstep(0.0, 1.0, gray);\r\n    return vec3(r, g, b);\r\n}\r\nvoid main() {\r\n    vec4 color = texture2D(texture, texCoords);\r\n    float intensity = color.r;\r\n    vec3 pseudocolor = grayscaleToColor(intensity);\r\n    gl_FragColor = vec4(pseudocolor, color.a);\r\n}",
    "SHARPENING": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 texSize;\r\nvoid main() {\r\n    float dx = 1.0 / texSize.x;\r\n    float dy = 1.0 / texSize.y;\r\n    float strength = 10.0; // Strength of sharpening effect\r\n    vec4 texColor = texture2D(texture, texCoords);\r\n    vec4 texColorLeft = texture2D(texture, texCoords + vec2(-dx, 0.0));\r\n    vec4 texColorRight = texture2D(texture, texCoords + vec2(dx, 0.0));\r\n    vec4 texColorUp = texture2D(texture, texCoords + vec2(0.0, dy));\r\n    vec4 texColorDown = texture2D(texture, texCoords + vec2(0.0, -dy));\r\n    vec4 edge = texColor * (1.0 + 4.0 * strength) - (texColorLeft + texColorRight + texColorUp + texColorDown) * strength;\r\n    gl_FragColor = vec4(edge.rgb, texColor.a);\r\n}",
    "SMILEY": "precision mediump float;\r\nuniform vec2 resolution; // Canvas size\r\nvoid main() {\r\n    vec2 center = vec2(0.5, 0.5); // Center of Smiley in normalised coordinates\r\n    float radius = 0.4; // Radius Smiley\r\n    float eyeRadius = 0.05;\r\n    float mouthWidth = 0.05;\r\n    float smileRadius = 0.3;\r\n    // Transform Pixel-coordinates to normalised coordinates\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec2 uvCentered = uv - center;\r\n    // Calculation distance from center\r\n    float dist = length(uvCentered);\r\n    // Draw Face\r\n    vec3 color = vec3(0.0);\r\n    if (dist < radius) {\r\n        color = vec3(1.0, 1.0, 0.0); // face in yellow\r\n        // Eyes\r\n        vec2 leftEyePos = center + vec2(-0.15, 0.1);\r\n        vec2 rightEyePos = center + vec2(0.15, 0.1);\r\n        float leftEyeDist = length(uv - leftEyePos);\r\n        float rightEyeDist = length(uv - rightEyePos);\r\n        if (leftEyeDist < eyeRadius || rightEyeDist < eyeRadius) {\r\n            color = vec3(0.0);\r\n        }\r\n        // Mouth\r\n        float mouthDist = length(uvCentered + vec2(0.0, -0.15));\r\n        if (mouthDist < smileRadius + mouthWidth && mouthDist > smileRadius - mouthWidth && uv.y < center.y) {\r\n            color = vec3(1.0, 0.0, 0.0); // mouth in red\r\n        }\r\n    }\r\n    gl_FragColor = vec4(color, 1.0);\r\n}",
    "SOBEL_EDGE": "precision mediump float;\r\nvarying vec2 texCoords;\r\nuniform sampler2D texture;\r\nuniform vec2 texSize;\r\nvoid main() {\r\n    float dx = 1.0 / texSize.x;\r\n    float dy = 1.0 / texSize.y;\r\n    vec3 grad_x = vec3(0.0);\r\n    vec3 grad_y = vec3(0.0);\r\n    vec3 texTL = texture2D(texture, texCoords + vec2(-dx, -dy)).rgb; // Top-left\r\n    vec3 texTC = texture2D(texture, texCoords + vec2(0.0, -dy)).rgb; // Top-center\r\n    vec3 texTR = texture2D(texture, texCoords + vec2(dx, -dy)).rgb;  // Top-right\r\n    vec3 texCL = texture2D(texture, texCoords + vec2(-dx, 0.0)).rgb; // Center-left\r\n    vec3 texCC = texture2D(texture, texCoords).rgb;                  // Center-center\r\n    vec3 texCR = texture2D(texture, texCoords + vec2(dx, 0.0)).rgb;  // Center-right\r\n    vec3 texBL = texture2D(texture, texCoords + vec2(-dx, dy)).rgb;  // Bottom-left\r\n    vec3 texBC = texture2D(texture, texCoords + vec2(0.0, dy)).rgb;  // Bottom-center\r\n    vec3 texBR = texture2D(texture, texCoords + vec2(dx, dy)).rgb;   // Bottom-right\r\n\r\n    // Apply Sobel operator for X gradient\r\n    grad_x += texTL * vec3(-1.0) + texTC * vec3(0.0) + texTR * vec3(1.0);\r\n    grad_x += texCL * vec3(-2.0) + texCC * vec3(0.0) + texCR * vec3(2.0);\r\n    grad_x += texBL * vec3(-1.0) + texBC * vec3(0.0) + texBR * vec3(1.0);\r\n\r\n    // Apply Sobel operator for Y gradient\r\n    grad_y += texTL * vec3(-1.0) + texTC * vec3(-2.0) + texTR * vec3(-1.0);\r\n    grad_y += texCL * vec3(0.0) + texCC * vec3(0.0) + texCR * vec3(0.0);\r\n    grad_y += texBL * vec3(1.0) + texBC * vec3(2.0) + texBR * vec3(1.0);\r\n\r\n    float edgeStrength = length(grad_x) + length(grad_y);\r\n    gl_FragColor = vec4(vec3(edgeStrength), 1.0);\r\n}"
};


async function $5ac0312f0689ba2d$var$startWebGLRipper() {
    // Declare global variables to store references to the window, pixel data, and WebGL context.
    let _window = window;
    let gl;
    let contextNames = [
        "webgl2",
        "webgl",
        "experimental-webgl"
    ];
    // Add the popup with a dropdown menu to the HTML document
    function createShaderSelectorPopup() {
        let popup = document.createElement("div");
        popup.style.position = "fixed";
        popup.style.top = "10px";
        popup.style.left = "10px";
        popup.style.padding = "10px";
        popup.style.backgroundColor = "white";
        popup.style.border = "2px solid red";
        popup.style.fontWeight = "bold";
        popup.style.zIndex = "10000"; // Ensures the dropdown is above other elements
        popup.style.pointerEvents = "auto"; // Ensures the dropdown is interactable
        let shaderOptions = Object.keys((0, $b2f097dd1b44c49c$export$866b86194d51abc4)).map((shader)=>`<option value="${shader}">${shader}</option>`).join("");
        popup.innerHTML = `
      <label for="shaderSelector">Select Fragment Shader:</label></br>
      <select id="shaderSelector">
        ${shaderOptions}
      </select>
    `;
        document.body.appendChild(popup);
        let shaderSelector = document.getElementById("shaderSelector");
        shaderSelector.addEventListener("change", function() {
            _window.Settings.globalFragmentShaderSetting = shaderSelector.value;
            updateShaderProgram();
        });
    }
    function chooseShaderOption(globalFragmentShaderSetting) {
        return (0, $b2f097dd1b44c49c$export$866b86194d51abc4)[globalFragmentShaderSetting];
    }
    _window.Settings = {
        CaptureSceneKeyCode: 45,
        CaptureTexturesKeyCode: 45,
        isDebug: true,
        counter: 0,
        version: 0,
        multipleCanvases: 0,
        // Coordinates for partial image processing area
        // TODO Boxcraft oder ähnliches integrieren, um Koordinaten abzurufen. Und diese dann setzen, für Verarbeitung im Fragment shader
        coordinatesLeftBottom: [
            150.0,
            110.0
        ],
        coordinatesRightTop: [
            280.0,
            260.0
        ],
        globalFragmentShaderSetting: "STANDARD" // Setting for different fragment shaders (Options: FRAG_SMILEY, FRAG_AREA, NULL->Standard)
    };
    // Function to log messages to the console if debugging is enabled.
    let LogToParent = function() {
        if (!_window.Settings.isDebug) return;
        _window.console.log("[WebGLRipper]", ...arguments);
    };
    _window.RIPPERS = [];
    // Event listener for keydown events to toggle image processing.
    document.addEventListener("keydown", function(event) {
        if (event.keyCode === _window.Settings.CaptureSceneKeyCode && !event.shiftKey) {
            if (_window.Settings.counter === 0) {
                _window.RIPPERS[0]._StartCapturing = true;
                _window.RIPPERS[0]._isCapturing = true;
                _window.Settings.counter = 1;
                LogToParent("Image-Processing activated.");
            } else {
                _window.RIPPERS[0]._StartCapturing = false;
                _window.RIPPERS[0]._IsEnabled = false;
                _window.RIPPERS[0]._isCapturing = false;
                _window.Settings.counter = 0;
                LogToParent("Image-Processing deactivated.");
            }
        }
    });
    // Defines a class to wrap around WebGL functionality.
    class WebGLWrapper {
        _StartCapturing = false;
        _IsEnabled = true;
        _IsWebGL2 = false;
        _GLViewport = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        _GLContext = null;
        _isCapturing = false;
        imageProcessingProgram = null;
        // Constructor initializes the wrapper with a WebGL context
        constructor(gl){
            this._GLContext = gl;
            this.initializeShaderProgram();
        }
        // Method to create and compile a shader
        createShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader compile failed: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        // Method to create a shader program from vertex and fragment shaders
        createProgram(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Program linking failed: " + gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }
        // Initializes shaders and stores the custom shader program for image processing
        initializeShaderProgram() {
            const gl = this._GLContext;
            const vertexShaderSource = `
                attribute vec2 position;
                varying vec2 texCoords;
                void main() {
                    texCoords = (position + 1.0) / 2.0;
                    gl_Position = vec4(position, 0, 1);
                }`;
            const fragmentShaderSource = chooseShaderOption(_window.Settings.globalFragmentShaderSetting);
            const vertexShader = this.createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = this.createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            this.imageProcessingProgram = this.createProgram(gl, vertexShader, fragmentShader);
        }
        // Handle viewport changes and apply the image processing shader (resolution conversion)
        hooked_viewport(self, gl, args, oFunc) {
            if (_window.Settings.counter == 1) {
                let _x = args[0];
                let _y = args[1];
                let _width = args[2];
                let _height = args[3];
                self._GLViewport = {
                    x: _x,
                    y: _y,
                    width: _width,
                    height: _height
                };
                oFunc.apply(gl, args);
                // Check if _GLViewport is defined
                if (!self._GLViewport || self._GLViewport.width === undefined || self._GLViewport.height === undefined) {
                    LogToParent("ERROR: Viewport is not defined or incomplete");
                    return;
                }
                //Checks if shader program had been initialised and assigned correctly
                if (self.imageProcessingProgram && gl.getUniformLocation(self.imageProcessingProgram, "resolution")) {
                    gl.useProgram(self.imageProcessingProgram);
                    var resolutionLocation = gl.getUniformLocation(self.imageProcessingProgram, "resolution");
                    gl.uniform2f(resolutionLocation, _width, _height);
                }
            }
        }
        // Process image data when drawElements is triggered.
        hooked_drawElements(self, gl, args, oFunc) {
            if (_window.Settings.counter == 1) {
                // Execute the original draw call to capture current state
                oFunc.apply(gl, args);
                // Setup empty texture to store framebuffer content
                var texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, self._GLViewport.width, self._GLViewport.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                // Create and bind Framebuffer, to render into texture instead of canvas
                var framebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, 0);
                // IMAGE processing:
                // use custom shader program
                gl.useProgram(self.imageProcessingProgram);
                // Variables for fragment shader; Coordinates used to do partial processing
                // TODO Make coordinates dynamic with boxcraft selection, otherwise allways full processing
                var bottomLeftLocation = gl.getUniformLocation(self.imageProcessingProgram, "bottomLeft");
                var topRightLocation = gl.getUniformLocation(self.imageProcessingProgram, "topRight");
                var resolutionLocation = gl.getUniformLocation(self.imageProcessingProgram, "resolution");
                gl.uniform2f(bottomLeftLocation, _window.Settings.coordinatesLeftBottom[0], _window.Settings.coordinatesLeftBottom[1]);
                gl.uniform2f(topRightLocation, _window.Settings.coordinatesRightTop[0], _window.Settings.coordinatesRightTop[1]);
                gl.uniform2f(resolutionLocation, gl.drawingBufferWidth, gl.drawingBufferHeight);
                var textureLocation = gl.getUniformLocation(self.imageProcessingProgram, "texture");
                gl.activeTexture(gl.TEXTURE0);
                // bind created texture which contains framebuffer content
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(textureLocation, 0);
                // Set texSize uniform
                var texSizeLocation = gl.getUniformLocation(self.imageProcessingProgram, "texSize");
                gl.uniform2f(texSizeLocation, self._GLViewport.width, self._GLViewport.height);
                // Redraw scene, but with modified shader program for pixel / image processing
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.deleteTexture(texture);
            } else oFunc.apply(gl, args);
        }
        // Method to update shader program when the dropdown selection changes
        updateShaderProgram() {
            this.initializeShaderProgram();
        }
    }
    // Register custom functions to intercept standard WebGL calls
    // Rebuilt from https://github.com/Rilshrink/WebGLRipper
    function RegisterGLFunction(_GL, _RipperWrapper, _Method) {
        if (_GL[_Method] === undefined) return;
        let hookFunc = _RipperWrapper[`hooked_${_Method}`];
        // Error if function type does not exist / is not defined
        if (!hookFunc) {
            LogToParent(`Wrapper didn't have the method '${_Method}' defined!`);
            return;
        }
        // Stores original function
        let originalFunc = _GL[_Method];
        // Replaces original function with custom version of it -> Overwrite / Monkey patching
        _GL[_Method] = function() {
            let rv = hookFunc(_RipperWrapper, this, arguments, originalFunc);
            if (rv) return rv;
            return originalFunc.apply(this, arguments);
        };
    }
    function updateShaderProgram() {}
    function initializeWebGL() {
        // Setup
        // Initialize the wrapper and set up the interception
        LogToParent("Attempting to hook into available Canvases!");
        // Call for all available canvases
        let canvases = document.querySelectorAll("canvas");
        // Iterate through all available canvases to check whether there is a available context to do processing on
        if (canvases.length != 0) for(_window.Settings.multipleCanvases = 0; _window.Settings.multipleCanvases < canvases.length; _window.Settings.multipleCanvases++){
            LogToParent("Hooking in Canvas: " + (_window.Settings.multipleCanvases + 1) + " / " + canvases.length);
            for(let version = 0; version < contextNames.length; _window.Settings.version++){
                gl = canvases[_window.Settings.multipleCanvases].getContext(contextNames[_window.Settings.version]);
                if (gl != null) break;
                LogToParent("Found no supported WebGL context.");
            }
            // Error handling, if no (supported) WebGL context could be set up
            try {
                if (!gl._hooked) {
                    // Creates new Instance of WebGLWrapper for received context
                    let glRipper = new WebGLWrapper(gl);
                    glRipper._IsWebGL2 = contextNames[_window.Settings.version] == "webgl2";
                    // Registers hooked functions in WebGL-Context.
                    RegisterGLFunction(gl, glRipper, "viewport");
                    RegisterGLFunction(gl, glRipper, "drawElements");
                    // Method to update shader program when the dropdown selection changes
                    updateShaderProgram = function() {
                        glRipper.initializeShaderProgram();
                    };
                    // Sets processing coordinates to full context size as standard, if no other value is set
                    // TODO Set coordinates for area of processing here, future integration of boxcraft for manual selection by user on canvas
                    if (_window.Settings.coordinatesLeftBottom[0] === 0.0 && _window.Settings.coordinatesLeftBottom[1] === 0.0) _window.Settings.coordinatesLeftBottom = [
                        0.0,
                        0.0
                    ];
                    if (_window.Settings.coordinatesRightTop[0] === 0.0 && _window.Settings.coordinatesRightTop[1] === 0.0) _window.Settings.coordinatesRightTop = [
                        gl.drawingBufferWidth,
                        gl.drawingBufferHeight
                    ];
                    _window.RIPPERS.push(glRipper);
                    gl._hooked = true;
                    LogToParent(`Injected into ` + contextNames[_window.Settings.version] + ` context of Canvas ` + (_window.Settings.multipleCanvases + 1));
                }
            } catch (error) {
                LogToParent("As no supported WebGL context was found, WebGLWrapper could not be setup and functions can't be hooked.\n For further information regard following error message: \n" + error);
            }
        }
        else LogToParent("No canvas was found on this website, thus no webgl context could be retrieved for image processing.");
    }
    initializeWebGL();
    createShaderSelectorPopup();
}
(function() {
    $5ac0312f0689ba2d$var$startWebGLRipper();
})();


